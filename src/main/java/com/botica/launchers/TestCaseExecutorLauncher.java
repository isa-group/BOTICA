package com.botica.launchers;

import static es.us.isa.restest.util.FileManager.createDir;
import static es.us.isa.restest.util.FileManager.deleteDir;

import org.json.JSONObject;

import com.botica.utils.BotConfig;
import com.botica.utils.RESTestUtil;

import es.us.isa.restest.runners.RESTestExecutor;

/**
 * This class is a launcher for executing test cases generated by generators.
 */
public class TestCaseExecutorLauncher extends AbstractLauncher{

    private static final String BOT_TYPE = "testCaseExecutor";
    private static final String BINDING_KEY = "testCasesGenerated";

    private String propertyFilePath;
    private String testCasesPath;

    public TestCaseExecutorLauncher(String keyToPublish, String orderToPublish) {
        super(keyToPublish, orderToPublish);
    }

    public TestCaseExecutorLauncher(String propertyFilePath, String testCasesPath, String keyToPublish, String orderToPublish) {
        super(keyToPublish, orderToPublish);
        this.propertyFilePath = propertyFilePath;
        this.testCasesPath = testCasesPath;
    }

    /**
     * Launches test case executor based on bot data provided, and sends and 
     * receives messages through RabbitMQ.
     *
     * @param botData           The JSON object containing bot data.
     * @param order             The order that identifies the message received.
     * @param keyToPublish      The binding key for publishing messages to RabbitMQ.
     * @param orderToPublish    The order to send in the message.
     */
    public void launchTestExecutor(JSONObject botData, String order) {
        
        BotConfig botConfig = new BotConfig(null, order, this.keyToPublish, this.orderToPublish, BOT_TYPE);
        String queueName = BOT_TYPE;
        launchBot(botData, botConfig, queueName, BINDING_KEY, false);
    }

    /**
     * Executes test cases generated.
     */
    @Override
    protected void botAction() {
        RESTestExecutor executor = new RESTestExecutor(propertyFilePath);

        // TODO: Check if is correct
        // Create directories to store test data extracted from the execution
        String experimentName = RESTestUtil.readProperty(propertyFilePath, "experiment.name");

        String testDataDir = RESTestUtil.readProperty(propertyFilePath, "data.tests.dir") + "/" + experimentName;
        String coverageDataDir = RESTestUtil.readProperty(propertyFilePath, "data.coverage.dir") + "/" + experimentName;
        String allureResultsDir = RESTestUtil.readProperty(propertyFilePath, "allure.results.dir") + "/" + experimentName;
        String allureReportDir = RESTestUtil.readProperty(propertyFilePath, "allure.report.dir") + "/" + experimentName;

        String deletePreviousResults = RESTestUtil.readProperty(propertyFilePath, "deletepreviousresults");
        if (deletePreviousResults != null && Boolean.parseBoolean(deletePreviousResults)) {
            deleteDir(testDataDir);
            deleteDir(coverageDataDir);
            deleteDir(allureResultsDir);
            deleteDir(allureReportDir);
        }

        createDir(testDataDir);
        createDir(coverageDataDir);
        //

        auxBotAction(executor);
    }

    private void auxBotAction(RESTestExecutor executor) {
        String allureResultsDirPath = RESTestUtil.readProperty(propertyFilePath, "allure.results.dir");
        String experimentName = RESTestUtil.readProperty(propertyFilePath, "experiment.name");
        System.setProperty("allure.results.directory", allureResultsDirPath + "/" + experimentName);
        executor.execute();
    }

    @Override
    protected JSONObject createMessage() {
        JSONObject message = new JSONObject();
        message.put("order", orderToPublish);
        message.put("propertyFilePath", propertyFilePath);
        message.put("testCasesPath", testCasesPath);

        return message;
    }
}
